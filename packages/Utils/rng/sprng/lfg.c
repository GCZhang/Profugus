/*CRCrem: 1571591324    This is an optional comment */
/*************************************************************************/
/*************************************************************************/
/* A MULTI-PROCESSOR LAGGED-FIBONACCI RANDOM NUMBER GENERATION SYSTEM    */
/*                                                                       */
/* Authors: Steven A. Cuccaro and Daniel V. Pryor,                       */
/*            IDA/Center for Computing Sciences (CCS)                    */
/* E-Mail: cuccaro@super.org      pryor@super.org                        */
/*                                                                       */
/* Copyright 1996 September 3, United States Government as Represented   */
/* by the Director, National Security Agency. All rights reserved.       */
/*                                                                       */
/* Disclaimer: CCS expressly disclaims any and all warranties, expressed */
/* or implied, concerning the enclosed software. This software was       */
/* developed at CCS for use in internal research. The intent in sharing  */
/* this software is to promote the productive interchange of ideas       */
/* throughout the research community. All software is furnished on an    */
/* "as is" basis. No further updates to this software should be          */
/* expected. Although this may occur, no commitment exists. The authors  */
/* certainly invite your comments as well as the reporting of any bugs.  */
/* CCS cannot commit that any or all bugs will be fixed.                 */
/*************************************************************************/
/*************************************************************************/

/*************************************************************************/
/*      This version has been modified to use two integer-based additive */
/*      lagged-Fibonacci generators to produce integer, float and double */
/*      values. The lagged-Fibonacci generators each have 31 bits of     */
/*      precision (after the bit fixed by the canonical form of the      */
/*      generator is removed), 31-bit values are generated by XORing     */
/*      the values after one has been shifted left one bit. The floating */
/*      point value is formed by dividing the integer by 1.e+32 (the     */
/*      lsb's will be dropped from the mantissa to make room for the     */
/*      exponent), and two of these integer values in sequence are used  */
/*      to get the necessary precision for the double value.             */
/*                                                                       */
/*      This method has the advantage that the generators pass fairly    */
/*      strict randomness tests, including the Birthday Spacings test    */
/*      that additive lagged-Fibonacci generators are well known to      */
/*      fail. The disadvantage is the additional time needed to do the   */
/*      division explicitly, which was avoided in previous versions.     */
/*      (As the division is by powers of 2, the user might well consider */
/*      making machine-specific versions of this code to insert the bits */
/*      into the appropriate places and avoid the problem entirely.)     */
/*************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include <assert.h>
#include "interface.h"
#include "memory.h"

/*#define PRINT_GEN*/

/*      BITS_IN_INT_GEN is the log_2 of the modulus of the generator     */
/*           for portability this is set to 32, but can be modified;     */
/*           if modified, make sure INT_MOD_MASK can still be calculated */
#define BITS_IN_INT_GEN 32

/*      INT_MOD_MASK is used to perform modular arithmetic - specifying  */
/*           this value compensates for different sized words on         */
/*           different architectures                                     */
/*      FLT_MULT is used in converting to float and double values; the   */
/*           odd form is due to a compiler glitch on our CM-5, which     */
/*           caused (0.5/(unsigned)(1<<31)) to be negative.              */
#if (BITS_IN_INT_GEN==32)
#define INT_MOD_MASK  0xffffffff
#define INT_MOD_MASK2 0xfffffffe

#define FLT_MULT (0.25f/(unsigned)((1u<<30) + (1u << 7)))
#define DBL_MULT (0.25/(unsigned)(1<<30))
#else
#define INT_MOD_MASK ((unsigned)(1<<BITS_IN_INT_GEN)-1)
#define FLT_MULT (1.0f/(1<<BITS_IN_INT_GEN))
#define DBL_MULT (1.0/(1<<BITS_IN_INT_GEN))
#endif
/*      INT_MASK is used to mask out the part of the generator which     */
/*           is not in the canonical form; it should be                  */
/*           2^{BITS_IN_INT_GEN-1}-1                                     */
#define INT_MASK ((unsigned)INT_MOD_MASK>>1)
/*      MAX_BIT_INT is the largest bit position allowed in the index     */
/*           of the node - it equals BITS_IN_INT_GEN - 2                 */
#define MAX_BIT_INT (BITS_IN_INT_GEN-2)
/*      INTX2_MASK is used in calculation of the node numbers            */
#define INTX2_MASK ((1<<MAX_BIT_INT)-1)

/*      RUNUP keeps certain generators from looking too similar in the   */
/*          first few words output                                       */
#define RUNUP (2*BITS_IN_INT_GEN)

/*      GS0 gives a more "random" distribution of generators when the    */
/*      user uses small integers as seeds                                */
#define GS0 0x372f05ac
#define TOOMANY "generator has branched maximum number of times;\nindependence of generators no longer guaranteed"


/*************************************************************************/
/*************************************************************************/
/*                  STRUCTURES AND GLOBAL DATA                           */
/*************************************************************************/
/*************************************************************************/

struct lfgen {
      unsigned *si;      /* sets next branch seed  */
      unsigned *r0;      /* pointer to the even generator */
      unsigned *r1;      /* pointer to the odd generator */
      int hptr;          /* integer pointer into fill */
      int seed;
      int init_seed;
      int lval, kval;
      int param;
};

int MAX_STREAMS=0x7fffffff;

struct vstruct {
      int L;
      int K;
      int LSBS;     /* number of least significant bits that are 1 */
      int first;    /* the first seed whose LSB is 1 */
};

const struct vstruct valid[] = { {1279,861,1,233},
                                 {17,5,1,10},
                                 {31,6,1,2},
                                 {55,24,1,11},
                                 {63,31,1,14},
                                 {127,97,1,21},
                                 {521,353,1,100},
                                 {521,168,1,83},
                                 {607,334,1,166},
                                 {607,273,1,105},
                                 {1279,418,1,208} };

#define NPARAMS 11

int gseed=0,lval=0,kval=0;
int NGENS = 0;

/*************************************************************************/
/*************************************************************************/
/*                    ERROR PRINTING FUNCTION                            */
/*************************************************************************/
/*************************************************************************/

#if __STDC__
static void errprint(char *level, char *routine, char *error)
#else
static int errprint(level, routine, error)
char *level,*routine,*error;
#endif
{
      fprintf(stderr,"%s from %s: %s\n",level,routine,error);
}

/*************************************************************************/
/*************************************************************************/
/*            ROUTINES USED TO CREATE GENERATOR FILLS                    */
/*************************************************************************/
/*************************************************************************/


/* The number of bits set in the binary representation of the integers 0-255 */
static const unsigned bitcount[256] =
    {
        0, /* 0 */	1, /* 1 */	1, /* 2 */	2, /* 3 */
        1, /* 4 */	2, /* 5 */	2, /* 6 */	3, /* 7 */
        1, /* 8 */	2, /* 9 */	2, /* 10 */	3, /* 11 */
        2, /* 12 */	3, /* 13 */	3, /* 14 */	4, /* 15 */
        1, /* 16 */	2, /* 17 */	2, /* 18 */	3, /* 19 */
        2, /* 20 */	3, /* 21 */	3, /* 22 */	4, /* 23 */
        2, /* 24 */	3, /* 25 */	3, /* 26 */	4, /* 27 */
        3, /* 28 */	4, /* 29 */	4, /* 30 */	5, /* 31 */
        1, /* 32 */	2, /* 33 */	2, /* 34 */	3, /* 35 */
        2, /* 36 */	3, /* 37 */	3, /* 38 */	4, /* 39 */
        2, /* 40 */	3, /* 41 */	3, /* 42 */	4, /* 43 */
        3, /* 44 */	4, /* 45 */	4, /* 46 */	5, /* 47 */
        2, /* 48 */	3, /* 49 */	3, /* 50 */	4, /* 51 */
        3, /* 52 */	4, /* 53 */	4, /* 54 */	5, /* 55 */
        3, /* 56 */	4, /* 57 */	4, /* 58 */	5, /* 59 */
        4, /* 60 */	5, /* 61 */	5, /* 62 */	6, /* 63 */
        1, /* 64 */	2, /* 65 */	2, /* 66 */	3, /* 67 */
        2, /* 68 */	3, /* 69 */	3, /* 70 */	4, /* 71 */
        2, /* 72 */	3, /* 73 */	3, /* 74 */	4, /* 75 */
        3, /* 76 */	4, /* 77 */	4, /* 78 */	5, /* 79 */
        2, /* 80 */	3, /* 81 */	3, /* 82 */	4, /* 83 */
        3, /* 84 */	4, /* 85 */	4, /* 86 */	5, /* 87 */
        3, /* 88 */	4, /* 89 */	4, /* 90 */	5, /* 91 */
        4, /* 92 */	5, /* 93 */	5, /* 94 */	6, /* 95 */
        2, /* 96 */	3, /* 97 */	3, /* 98 */	4, /* 99 */
        3, /* 100 */	4, /* 101 */	4, /* 102 */	5, /* 103 */
        3, /* 104 */	4, /* 105 */	4, /* 106 */	5, /* 107 */
        4, /* 108 */	5, /* 109 */	5, /* 110 */	6, /* 111 */
        3, /* 112 */	4, /* 113 */	4, /* 114 */	5, /* 115 */
        4, /* 116 */	5, /* 117 */	5, /* 118 */	6, /* 119 */
        4, /* 120 */	5, /* 121 */	5, /* 122 */	6, /* 123 */
        5, /* 124 */	6, /* 125 */	6, /* 126 */	7, /* 127 */
        1, /* 128 */	2, /* 129 */	2, /* 130 */	3, /* 131 */
        2, /* 132 */	3, /* 133 */	3, /* 134 */	4, /* 135 */
        2, /* 136 */	3, /* 137 */	3, /* 138 */	4, /* 139 */
        3, /* 140 */	4, /* 141 */	4, /* 142 */	5, /* 143 */
        2, /* 144 */	3, /* 145 */	3, /* 146 */	4, /* 147 */
        3, /* 148 */	4, /* 149 */	4, /* 150 */	5, /* 151 */
        3, /* 152 */	4, /* 153 */	4, /* 154 */	5, /* 155 */
        4, /* 156 */	5, /* 157 */	5, /* 158 */	6, /* 159 */
        2, /* 160 */	3, /* 161 */	3, /* 162 */	4, /* 163 */
        3, /* 164 */	4, /* 165 */	4, /* 166 */	5, /* 167 */
        3, /* 168 */	4, /* 169 */	4, /* 170 */	5, /* 171 */
        4, /* 172 */	5, /* 173 */	5, /* 174 */	6, /* 175 */
        3, /* 176 */	4, /* 177 */	4, /* 178 */	5, /* 179 */
        4, /* 180 */	5, /* 181 */	5, /* 182 */	6, /* 183 */
        4, /* 184 */	5, /* 185 */	5, /* 186 */	6, /* 187 */
        5, /* 188 */	6, /* 189 */	6, /* 190 */	7, /* 191 */
        2, /* 192 */	3, /* 193 */	3, /* 194 */	4, /* 195 */
        3, /* 196 */	4, /* 197 */	4, /* 198 */	5, /* 199 */
        3, /* 200 */	4, /* 201 */	4, /* 202 */	5, /* 203 */
        4, /* 204 */	5, /* 205 */	5, /* 206 */	6, /* 207 */
        3, /* 208 */	4, /* 209 */	4, /* 210 */	5, /* 211 */
        4, /* 212 */	5, /* 213 */	5, /* 214 */	6, /* 215 */
        4, /* 216 */	5, /* 217 */	5, /* 218 */	6, /* 219 */
        5, /* 220 */	6, /* 221 */	6, /* 222 */	7, /* 223 */
        3, /* 224 */	4, /* 225 */	4, /* 226 */	5, /* 227 */
        4, /* 228 */	5, /* 229 */	5, /* 230 */	6, /* 231 */
        4, /* 232 */	5, /* 233 */	5, /* 234 */	6, /* 235 */
        5, /* 236 */	6, /* 237 */	6, /* 238 */	7, /* 239 */
        4, /* 240 */	5, /* 241 */	5, /* 242 */	6, /* 243 */
        5, /* 244 */	6, /* 245 */	6, /* 246 */	7, /* 247 */
        5, /* 248 */	6, /* 249 */	6, /* 250 */	7, /* 251 */
        6, /* 252 */	7, /* 253 */	7, /* 254 */	8  /* 255 */
    };


/*
  Given the code snippet:

    const unsigned mask = 0x1b;
    unsigned new_fill = 0;
    for (i=0; i < 4; ++i)
       new_fill |=  (1&bitcount[(val >> i)&mask]) << i;

  the following array precomputes values of new_fill for val=0..255
*/
static const unsigned mask_gen[256] = {
    0, /*   0 */    1, /*   1 */    3, /*   2 */    2, /*   3 */
    6, /*   4 */    7, /*   5 */    5, /*   6 */    4, /*   7 */
   13, /*   8 */   12, /*   9 */   14, /*  10 */   15, /*  11 */
   11, /*  12 */   10, /*  13 */    8, /*  14 */    9, /*  15 */
   11, /*  16 */   10, /*  17 */    8, /*  18 */    9, /*  19 */
   13, /*  20 */   12, /*  21 */   14, /*  22 */   15, /*  23 */
    6, /*  24 */    7, /*  25 */    5, /*  26 */    4, /*  27 */
    0, /*  28 */    1, /*  29 */    3, /*  30 */    2, /*  31 */
    6, /*  32 */    7, /*  33 */    5, /*  34 */    4, /*  35 */
    0, /*  36 */    1, /*  37 */    3, /*  38 */    2, /*  39 */
   11, /*  40 */   10, /*  41 */    8, /*  42 */    9, /*  43 */
   13, /*  44 */   12, /*  45 */   14, /*  46 */   15, /*  47 */
   13, /*  48 */   12, /*  49 */   14, /*  50 */   15, /*  51 */
   11, /*  52 */   10, /*  53 */    8, /*  54 */    9, /*  55 */
    0, /*  56 */    1, /*  57 */    3, /*  58 */    2, /*  59 */
    6, /*  60 */    7, /*  61 */    5, /*  62 */    4, /*  63 */
   12, /*  64 */   13, /*  65 */   15, /*  66 */   14, /*  67 */
   10, /*  68 */   11, /*  69 */    9, /*  70 */    8, /*  71 */
    1, /*  72 */    0, /*  73 */    2, /*  74 */    3, /*  75 */
    7, /*  76 */    6, /*  77 */    4, /*  78 */    5, /*  79 */
    7, /*  80 */    6, /*  81 */    4, /*  82 */    5, /*  83 */
    1, /*  84 */    0, /*  85 */    2, /*  86 */    3, /*  87 */
   10, /*  88 */   11, /*  89 */    9, /*  90 */    8, /*  91 */
   12, /*  92 */   13, /*  93 */   15, /*  94 */   14, /*  95 */
   10, /*  96 */   11, /*  97 */    9, /*  98 */    8, /*  99 */
   12, /* 100 */   13, /* 101 */   15, /* 102 */   14, /* 103 */
    7, /* 104 */    6, /* 105 */    4, /* 106 */    5, /* 107 */
    1, /* 108 */    0, /* 109 */    2, /* 110 */    3, /* 111 */
    1, /* 112 */    0, /* 113 */    2, /* 114 */    3, /* 115 */
    7, /* 116 */    6, /* 117 */    4, /* 118 */    5, /* 119 */
   12, /* 120 */   13, /* 121 */   15, /* 122 */   14, /* 123 */
   10, /* 124 */   11, /* 125 */    9, /* 126 */    8, /* 127 */
    8, /* 128 */    9, /* 129 */   11, /* 130 */   10, /* 131 */
   14, /* 132 */   15, /* 133 */   13, /* 134 */   12, /* 135 */
    5, /* 136 */    4, /* 137 */    6, /* 138 */    7, /* 139 */
    3, /* 140 */    2, /* 141 */    0, /* 142 */    1, /* 143 */
    3, /* 144 */    2, /* 145 */    0, /* 146 */    1, /* 147 */
    5, /* 148 */    4, /* 149 */    6, /* 150 */    7, /* 151 */
   14, /* 152 */   15, /* 153 */   13, /* 154 */   12, /* 155 */
    8, /* 156 */    9, /* 157 */   11, /* 158 */   10, /* 159 */
   14, /* 160 */   15, /* 161 */   13, /* 162 */   12, /* 163 */
    8, /* 164 */    9, /* 165 */   11, /* 166 */   10, /* 167 */
    3, /* 168 */    2, /* 169 */    0, /* 170 */    1, /* 171 */
    5, /* 172 */    4, /* 173 */    6, /* 174 */    7, /* 175 */
    5, /* 176 */    4, /* 177 */    6, /* 178 */    7, /* 179 */
    3, /* 180 */    2, /* 181 */    0, /* 182 */    1, /* 183 */
    8, /* 184 */    9, /* 185 */   11, /* 186 */   10, /* 187 */
   14, /* 188 */   15, /* 189 */   13, /* 190 */   12, /* 191 */
    4, /* 192 */    5, /* 193 */    7, /* 194 */    6, /* 195 */
    2, /* 196 */    3, /* 197 */    1, /* 198 */    0, /* 199 */
    9, /* 200 */    8, /* 201 */   10, /* 202 */   11, /* 203 */
   15, /* 204 */   14, /* 205 */   12, /* 206 */   13, /* 207 */
   15, /* 208 */   14, /* 209 */   12, /* 210 */   13, /* 211 */
    9, /* 212 */    8, /* 213 */   10, /* 214 */   11, /* 215 */
    2, /* 216 */    3, /* 217 */    1, /* 218 */    0, /* 219 */
    4, /* 220 */    5, /* 221 */    7, /* 222 */    6, /* 223 */
    2, /* 224 */    3, /* 225 */    1, /* 226 */    0, /* 227 */
    4, /* 228 */    5, /* 229 */    7, /* 230 */    6, /* 231 */
   15, /* 232 */   14, /* 233 */   12, /* 234 */   13, /* 235 */
    9, /* 236 */    8, /* 237 */   10, /* 238 */   11, /* 239 */
    9, /* 240 */    8, /* 241 */   10, /* 242 */   11, /* 243 */
   15, /* 244 */   14, /* 245 */   12, /* 246 */   13, /* 247 */
    4, /* 248 */    5, /* 249 */    7, /* 250 */    6, /* 251 */
    2, /* 252 */    3, /* 253 */    1, /* 254 */    0  /* 255 */

};




/**************************/
/* function advance_reg:  */
/**************************/
#if __STDC__
static void advance_reg(int *reg_fill)
#else
    static void advance_reg(reg_fill)
     int *reg_fill;
#endif
{
    /*      the register steps according to the primitive polynomial         */
    /*           (64,4,3,1,0); each call steps register 64 times             */
    /*      we use two words to represent the register to allow for integer  */
    /*           size of 32 bits                                             */


    /* NOTE: if this changes from 0x1b, the contents of the mask_gen array
       need to be recomputed! */
    const unsigned int mask = 0x1b;

    int i;
    unsigned new_fill0 = 0;
    unsigned new_fill1 = 0;
    unsigned temp;
    const unsigned urf0 = (unsigned)reg_fill[0];
    const unsigned urf1 = (unsigned)reg_fill[1];
    const unsigned urf0_sr_24 = urf0 >> 24;

/* Commenting out to avoid unused variable warning - TME
    const unsigned adv_64[4][2] = {
        {0xb0000000, 0x1b},
        {0x60000000, 0x2d},
        {0xc0000000, 0x5a},
        {0x80000000, 0xaf} };
*/

    for (i=0; i < 28; i+=4)
    {
        new_fill0 |= mask_gen[(urf0 >> i)&255] << i;
        new_fill1 |= mask_gen[(urf1 >> i)&255] << i;
    }

    /* i = 28 */
    temp = bitcount[(urf0 >> 28)&mask];
    temp ^= bitcount[urf1&(mask>>4)];
    new_fill0 |= (1&temp)<<28;

    temp = bitcount[urf0_sr_24 & 0xb0];
    temp ^= bitcount[urf1 & 0x1b];
    new_fill1 |= (1&temp)<<28;

    /* i = 29 */

    temp = bitcount[(urf0 >> 29)&mask];
    temp ^= bitcount[urf1&(mask>>3)];
    new_fill0 |= (1&temp)<<29;

    temp = bitcount[urf0_sr_24 & 0x60];
    temp ^= bitcount[urf1 & 0x2d];
    new_fill1 |= (1&temp)<<29;

    /* i = 30 */

    temp = bitcount[(urf0 >> 30)&mask];
    temp ^= bitcount[urf1&(mask>>2)];
    new_fill0 |= (1&temp)<<30;

    temp = bitcount[urf0_sr_24 & 0xc0];
    temp ^= bitcount[urf1 & 0x5a];
    new_fill1 |= (1&temp)<<30;

    /* i = 31 */

    temp = bitcount[(urf0 >> 31)&mask];
    temp ^= bitcount[urf1&(mask>>1)];
    new_fill0 |= (1&temp)<<31;

    temp = bitcount[urf0_sr_24 & 0x80];
    temp ^= bitcount[urf1 & 0xaf];
    new_fill1 |= (1&temp)<<31;


    reg_fill[0] = new_fill0;
    reg_fill[1] = new_fill1;
}

/**************************/
/*   function get_fill:   */
/**************************/

#if __STDC__
static int get_fill( unsigned *n, unsigned *r, int param, unsigned seed)
#else
static int get_fill(n,r, param, seed)
unsigned *n, *r, seed;
int param;
#endif
{
    int i,j,k,temp[2];

    const int length = valid[param].L;

/*      initialize the shift register with the node number XORed with    */
/*           the global seed                                             */
/*      fill the shift register with two copies of this number           */
/*           except when equal to zero                                   */
  temp[1] = temp[0] = n[0]^seed;
  if (!temp[0])
    temp[0] = GS0;

/*      advance the shift register some                                  */
  advance_reg(temp);
  advance_reg(temp);

/*      the first word in the generator is defined by the 31 LSBs of the */
/*           node number                                                 */
  r[0] = (INT_MASK&n[0])<<1;
/*      the generator is filled with the lower 31 bits of the shift      */
/*           register at each time, shifted up to make room for the bits */
/*           defining the canonical form; the node number is XORed into  */
/*           the fill to make the generators unique                      */
  for (i=1;i<length-1;i++)
  {
    advance_reg(temp);
    r[i] = (INT_MASK&(temp[0]^n[i]))<<1;
  }
  r[length-1] = 0;
/*      the canonical form for the LSB is instituted here                */
  k = valid[param].first + valid[param].LSBS;

  for (j=valid[param].first;j<k;j++)
      r[j] |= 1;


  return(0);
}

/*************************************************************************/
/*************************************************************************/
/*            SI_DOUBLE: updates index for next spawning                 */
/*************************************************************************/
/*************************************************************************/

#if __STDC__
static void si_double(unsigned *a,  unsigned *b, int length)
#else
static void si_double(a,b, length)
unsigned *a,*b;
int length;
#endif
{
  int i;

  if (b[length-2]&(1<<MAX_BIT_INT))
    errprint("WARNING","si_double",TOOMANY);
  a[length-2] = (INTX2_MASK&b[length-2])<<1;

  for (i=length-3;i>=0;i--)
  {
    if (b[i]&(1<<MAX_BIT_INT))
      a[i+1]++;
    a[i] = (INTX2_MASK&b[i])<<1;
  }
}

/*************************************************************************/
/*************************************************************************/
/*            GET_RN: returns generated random number                    */
/*************************************************************************/
/*************************************************************************/

#if __STDC__
int get_rn_int(int *genptr)
#else
int get_rn_int(genptr)
int *genptr;
#endif
/*      returns value put into new position                              */
{
        unsigned new_val,*r0,*r1;
        int hptr,lptr,*hp = &((struct lfgen *)genptr)->hptr;
        int lval, kval;

        lval = ((struct lfgen *)genptr)->lval;
        kval = ((struct lfgen *)genptr)->kval;
        r0 = ((struct lfgen *)genptr)->r0;
        r1 = ((struct lfgen *)genptr)->r1;
        hptr = *hp;
        lptr = hptr + kval;
        if (lptr>=lval) lptr -= lval;
/*    INT_MOD_MASK causes arithmetic to be modular when integer size is  */
/*         different from generator modulus                              */
        r0[hptr] = INT_MOD_MASK&(r0[hptr] + r0[lptr]);
        r1[hptr] = INT_MOD_MASK&(r1[hptr] + r1[lptr]);
        new_val = (r1[hptr]&(~1)) ^ (r0[hptr]>>1);
        if (--hptr < 0) hptr = lval - 1; /* skip an element in the sequence */
        if (--lptr < 0) lptr = lval - 1;
        r0[hptr] = INT_MOD_MASK&(r0[hptr] + r0[lptr]);
        r1[hptr] = INT_MOD_MASK&(r1[hptr] + r1[lptr]);
        *hp = (--hptr < 0) ? lval-1 : hptr;


        return (new_val>>1);
}


#if __STDC__
float get_rn_flt(int *genptr)
#else
float get_rn_flt(genptr)
int *genptr;
#endif
/*      returns value put into new position                              */
{
    unsigned long new_val; /* this cannot be unsigned int due to a bug in the SGI compiler */
    unsigned  *r0,*r1;
    int hptr,lptr,*hp = &((struct lfgen *)genptr)->hptr;
    int lval, kval;

    lval = ((struct lfgen *)genptr)->lval;
    kval = ((struct lfgen *)genptr)->kval;
    r0 = ((struct lfgen *)genptr)->r0;
    r1 = ((struct lfgen *)genptr)->r1;
    hptr = *hp;
    lptr = hptr + kval;
    if (lptr>=lval) lptr -= lval;
    /*    INT_MOD_MASK causes arithmetic to be modular when integer size is  */
    /*         different from generator modulus                              */
    r0[hptr] = INT_MOD_MASK & (r0[hptr] + r0[lptr]);
    r1[hptr] = INT_MOD_MASK & (r1[hptr] + r1[lptr]);
    new_val = (r1[hptr]&(~1)) ^ (r0[hptr]>>1);
    if (--hptr < 0) hptr = lval - 1; /* skip an element in the sequence */
    if (--lptr < 0) lptr = lval - 1;
    r0[hptr] = INT_MOD_MASK&(r0[hptr] + r0[lptr]);
    r1[hptr] = INT_MOD_MASK&(r1[hptr] + r1[lptr]);
    *hp = (--hptr<0) ? lval-1 : hptr;

    return (new_val*FLT_MULT);
}

#if __STDC__
double get_rn_dbl(int *genptr)
#else
double get_rn_dbl(genptr)
int *genptr;
#endif
/*      returns value put into new position                              */
{
    unsigned *r0,*r1;
    unsigned long temp1,temp2; /* Due to a bug in the SGI compiler, this should not be unsigned int */
    int hptr,lptr,*hp = &((struct lfgen *)genptr)->hptr;
    double new_val;
    int lval, kval;

    lval = ((struct lfgen *)genptr)->lval;
    kval = ((struct lfgen *)genptr)->kval;
    r0 = ((struct lfgen *)genptr)->r0;
    r1 = ((struct lfgen *)genptr)->r1;
    hptr = *hp;
    lptr = hptr + kval;
    if (lptr>=lval) lptr -= lval;
    /*    INT_MOD_MASK causes arithmetic to be modular when integer size is  */
    /*         different from generator modulus                              */
    r0[hptr] = INT_MOD_MASK&(r0[hptr] + r0[lptr]);
    r1[hptr] = INT_MOD_MASK&(r1[hptr] + r1[lptr]);
    temp1 = (r1[hptr]&(~1)) ^ (r0[hptr]>>1);
    if (--hptr < 0) hptr = lval - 1;
    if (--lptr < 0) lptr = lval - 1;
    r0[hptr] = INT_MOD_MASK&(r0[hptr] + r0[lptr]);
    r1[hptr] = INT_MOD_MASK&(r1[hptr] + r1[lptr]);
    temp2 = (r1[hptr]&(~1)) ^ (r0[hptr]>>1);
    *hp = (--hptr < 0) ? lval-1 : hptr;

    new_val = ((unsigned int)temp2 * (double)DBL_MULT + (unsigned int)temp1) * DBL_MULT;
    return (new_val);
}

/*************************************************************************/
/*************************************************************************/
/*            INITIALIZE: starts the whole thing going                   */
/*************************************************************************/
/*************************************************************************/

#define OLD 0
static int *order = 0;
static int order_size = 0;

static int **initialize(int ngen, int param, unsigned seed, unsigned *nstart, unsigned initseed)
{
    int i,j,k,l;

  struct lfgen **q;
  unsigned *nindex;

  const int length = valid[param].L;
  const unsigned desired_order_size = ngen * sizeof(int);
  const unsigned desired_malloc = (3*length-1)*sizeof(unsigned);

/*      allocate memory for node number and fill of each generator       */
  if(desired_order_size > order_size)
  {
      if(order) free(order);
      order = (int *) mymalloc(desired_order_size);
      order_size = desired_order_size;
  }

  q = (struct lfgen **) mymalloc(ngen*sizeof(struct lfgen *));
  if (q == NULL || order == NULL)
    return NULL;

  for (i=0;i<ngen;i++)
  {
    q[i] = (struct lfgen *) mymalloc(sizeof(struct lfgen));
    if (q[i] == NULL)
      return NULL;

    q[i]->hptr = length - 1;
#if OLD
    q[i]->si = (unsigned *) mymalloc((length-1)*sizeof(unsigned));
    q[i]->r0 = (unsigned *) mymalloc(length*sizeof(unsigned));
    q[i]->r1 = (unsigned *) mymalloc(length*sizeof(unsigned));
#else
    q[i]->si = (unsigned *) mymalloc(desired_malloc);
    q[i]->r0 = (unsigned *) (q[i]->si + length - 1);
    q[i]->r1 = (unsigned *) (q[i]->r0 + length);
#endif
    q[i]->lval = length;
    q[i]->kval = valid[param].K;
    q[i]->param = param;
    q[i]->seed = seed;
    q[i]->init_seed = initseed;

#if OLD
    if (q[i]->r1 == NULL || q[i]->r0 == NULL || q[i]->si == NULL)
        return NULL;
#else
    if (q[i]->si == NULL)
      return NULL;
#endif


  }
/*      specify register fills and node number arrays                    */
/*      do fills in tree fashion so that all fills branch from index     */
/*           contained in nstart array                                   */
  si_double(q[0]->si,nstart,length);
  get_fill(q[0]->si,q[0]->r0,param,seed);
  q[0]->si[0]++;
  get_fill(q[0]->si,q[0]->r1,param,seed);

  i = 1;
  order[0] = 0;
  if (ngen>1)
    while (1)
    {
      l = i;
      for (k=0;k<l;k++)
      {
        nindex = q[order[k]]->si;
        si_double(nindex,nindex, length);
        for (j=0;j<length-1;j++)
          q[i]->si[j] = nindex[j];
        get_fill(q[i]->si,q[i]->r0,param,seed);
        q[i]->si[0]++;
        get_fill(q[i]->si,q[i]->r1,param,seed);
        if (ngen == ++i)
          break;
      }

      if (ngen == i)
        break;

      for (k=l-1;k>0;k--)
      {
        order[2*k+1] = l+k;
        order[2*k] = order[k];
      }
      order[1] = l;
    }


  for (i=ngen-1;i>=0;i--)
  {
    k = 0;
    for (j=1;j<lval-1 && !k;j++)
        k = (q[i]->si[j] != 0);
    if (!k)
      break;
    for (j=0;j<length*RUNUP;j++)
      get_rn_int((int *)(q[i]));
  }

  k = length<<2;
  while (!(i<0))
  {
    for (j = 0; j < k; ++j)
      get_rn_int((int *)(q[i]));
    --i;
  }

  return((int **)q);
}

/*************************************************************************/
/*************************************************************************/
/*            INIT_RNG's: user interface to start things off             */
/*************************************************************************/
/*************************************************************************/

#if __STDC__
int *init_rng( int gennum,  int total_gen,  int seed, int param)
#else
int *init_rng(gennum,total_gen,seed,param)
int gennum,param,seed,total_gen;
#endif
{
  int doexit=0,i,k, length;
  int **p=NULL, *rng;
  unsigned *nstart=NULL,*si;


/*      gives back one generator (node gennum) with updated spawning     */
/*      info; should be called total_gen times, with different value     */
/*      of gennum in [0,total_gen) each call                             */

/*      check values of gennum and total_gen                             */

  if (total_gen <= 0) /* check if total_gen is valid */
  {
    total_gen = 1;
    errprint("WARNING","init_rng","Total_gen <= 0. Default value of 1 used for total_gen");
  }

  if (gennum >= MAX_STREAMS) /* check if gen_num is valid    */
    fprintf(stderr,"WARNING - init_rng: gennum: %d > maximum number of independent streams: %d\n\tIndependence of streams cannot be guranteed.\n",
            gennum, MAX_STREAMS);

  if (gennum < 0 || gennum >= total_gen) /* check if gen_num is valid */
  {
    errprint("ERROR","init_rng","gennum out of range. ");
    return (int *) NULL;
  }

  seed &= 0x7fffffff;		/* Only 32 LSB of seed considered */

  if (param < 0 || param >= NPARAMS)
  {
    errprint("WARNING","init_rng","Parameter not valid. Using Default param");
    param = 0;
  }

/*      check whether generators have previously been defined            */
/*      guard against access while defining generator parameters for     */
/*            the 1st time                                               */
  length = valid[param].L; /* determine parameters   */
  k = valid[param].K;
  if (!lval)
  {
    lval = length; /* determine parameters   */
    kval = k;
    gseed = seed^GS0;
  }
  else
  {
    if (lval != length)
      doexit++;
    if( seed != (gseed^GS0) )
      doexit += 2;

    if (doexit)
    {
      if (doexit&1)
        errprint("WARNING","init_rng","changing global L value! Independence of streams is not guaranteed");
      if (doexit&2)
        errprint("WARNING","init_rng","changing global seed value! Independence of streams is not guaranteed");
    }
  }

/*      define the starting vector for the initial node                  */
  nstart = (unsigned *) mymalloc((length-1)*sizeof(unsigned));
  if (nstart == NULL)
    return NULL;

  nstart[0] = gennum;
  for (i=1;i<length-1;i++)
    nstart[i] = 0;

  p = initialize(1,param,seed^GS0,nstart,seed);  /* create a generator  */
  if (p==NULL)
    return NULL;

/*      update si array to allow for future spawning of generators       */
  si = ((struct lfgen *)(p[0]))->si;
  while (si[0] < total_gen && !si[1])
    si_double(si,si,length);

  NGENS++;

  free(nstart);

  rng = p[0];
  free(p);

  return rng;
}


/*************************************************************************/
/*************************************************************************/
/*                  SPAWN_RNG: spawns new generators                     */
/*************************************************************************/
/*************************************************************************/

#if __STDC__
int spawn_rng(int *genptr,  int nspawned, int ***newgens, int checkid)
#else
int spawn_rng(genptr,nspawned,newgens, checkid)
int *genptr,nspawned, ***newgens, checkid;
#endif
{
  int **q=NULL, i;
  unsigned *p;
  struct lfgen *temp;

  if (nspawned <= 0) /* check if nspawned is valid */
  {
    nspawned = 1;
    errprint("WARNING","spawn_rng","Nspawned <= 0. Default value of 1 used for nspawned");
  }

  temp = (struct lfgen *) genptr;

  p = temp->si;

  q = initialize(nspawned,temp->param,temp->seed,p,temp->init_seed);

  if (q == NULL)
    {
      *newgens = NULL;
      return 0;
    }

  si_double(p,p,temp->lval);

  NGENS += nspawned;

  *newgens = (int **) q;

  if(checkid != 0)
    for(i=0; i<nspawned; i++)
      if(addID((*newgens)[i]) == NULL)
        return i;

  return nspawned;
}

/*************************************************************************/
/*************************************************************************/
/*                  UTILITY ROUTINES                                     */
/*************************************************************************/
/*************************************************************************/

/* These functions aren't called anywhere, so comment them out - TME
#if __STDC__
static int get_llag_rng(void)
#else
static int get_llag_rng()
#endif
{
        return(lval);
}

#if __STDC__
static int get_klag_rng(void)
#else
static int get_klag_rng()
#endif
{
        return(kval);
}

#if __STDC__
static int get_hptr_rng( int *genptr)
#else
static int get_hptr_rng(genptr)
int *genptr;
#endif
{
        return (((struct lfgen *)genptr)->hptr);
}

#if __STDC__
static int *get_fill_rng( int *genptr)
#else
static int *get_fill_rng(genptr)
int *genptr;
#endif
{
  int i,*p;
  unsigned *pp;
  struct lfgen *temp;

  temp = (struct lfgen *) genptr;

  p = (int *) mymalloc(2*(temp->lval)*sizeof(int));
  if(p == NULL)
    return NULL;

  pp = ((struct lfgen *)genptr)->r0;
  for (i=0;i<lval;i++)
    p[i] = pp[i];
  pp = ((struct lfgen *)genptr)->r1;
  for (i=0;i<temp->lval;i++)
    p[temp->lval+i] = pp[i];

  return(p);
}

#if __STDC__
static int *get_node_index_rng( int *genptr)
#else
static int *get_node_index_rng(genptr)
int *genptr;
#endif
{
  int *p, length;

  length = ( (struct lfgen *) genptr)->lval;

  p = get_next_index_rng(genptr);
  if(p == NULL)
    return NULL;

  while (!(p[0]&1))
    si_halve(p,length);
  si_halve(p, length);

  return(p);
}

#if __STDC__
int get_seed_rng(int *gen)
#else
int get_seed_rng(gen)
int *gen;
#endif
{
        return(GS0^gseed);
}

#if __STDC__
static int *get_next_index_rng( int *genptr)
#else
static int *get_next_index_rng(genptr)
int *genptr;
#endif
{
  int i,*p, lval;
  unsigned *pp;

  lval = ((struct lfgen *) genptr)->lval;

  pp = ((struct lfgen *)genptr)->si;
  p = (int *) mymalloc((lval-1)*sizeof(int));
  if(p == NULL)
    return NULL;

  for (i=0;i<lval-1;i++)
    p[i] = pp[i];

  return(p);
}

#if __STDC__
static void si_halve(int *a, int length)
#else
static void si_halve(a, length)
int *a, length;
#endif
{
  int i;

  for (i=0;i<length-2;i++)
  {
    a[i] >>= 1;
    if (a[i+1]&1)
      a[i] ^= (1<<MAX_BIT_INT);
  }

  a[length-2] >>= 1;
}
*/

#if __STDC__
int get_seed_rng(int *gen)
#else
int get_seed_rng(gen)
int *gen;
#endif
{
        return(GS0^gseed);
}


/*************************************************************************/
/*************************************************************************/
/*                  MESSAGE PASSING ROUTINES                             */
/*************************************************************************/
/*************************************************************************/


#if __STDC__
int pack_rng( int *genptr, char **buffer)
#else
int pack_rng(genptr,buffer)
int *genptr;
char **buffer;
#endif
{
  int i,*p, size;
  struct lfgen *q;

  q = (struct lfgen *)genptr;
  size = (3*(q->lval)+4)*sizeof(int);
  p = (int *) mymalloc(size);
  if (p == NULL)
    return 0;

  p[0] = q->lval;
  p[1] = q->kval;
  p[2] = q->seed;
  p[3] = q->init_seed;

  for (i=0;i<q->lval-1;i++)
    p[i+4] = q->si[i];

  for (i=0;i<q->lval;i++)
    p[q->lval+i+3] = q->r0[i];

  for (i=0;i<q->lval;i++)
    p[2*q->lval+i+3] = q->r1[i];

  p[3*q->lval+3] = q->hptr;

  *buffer = (char *) p;
  return size;
}


#if __STDC__
int *unpack_rng( char *p)
#else
int *unpack_rng(p)
char *p;
#endif
{
  int doexit=0,i, found, length, k, *packed, param;
  struct lfgen *q;
  unsigned seed;
  int desired_malloc;

  packed = (int *) p;

/*      check values of parameters for consistency                       */
  if (!lval)
  {
    for(i=found=0; i<NPARAMS; i++)
      if(packed[0]==valid[i].L && packed[1]==valid[i].K)
      {
        found = 1;
        break;
      }

    if(found == 0)
    {
      fprintf(stderr,"ERROR: Unpacked parameters are not acceptable.\n");
      return NULL;
    }
    param = i;
    length = lval = valid[i].L;
    k = kval = valid[i].K;
    seed = gseed = packed[2];
  }
  else
  {
    if (packed[0]!=lval)
      doexit++;
    if (packed[1]!=kval)
      doexit += 2;
    if (packed[2]!=gseed)
      doexit += 4;

    if (doexit)
    {
      if (doexit&1)
        errprint("WARNING","unpack_rng","different global L value!");
      if (doexit&2)
        errprint("WARNING","unpack_rng","different global K value!");
      if (doexit&4)
        errprint("WARNING","unpack_rng","different global seed value!");

      fprintf(stderr,"\t Independence of streams is not guaranteed\n");
    }

    for(i=found=0; i<NPARAMS; i++)
      if(packed[0]==valid[i].L && packed[1]==valid[i].K)
      {
        found = 1;
        break;
      }

    if(found == 0)
    {
      fprintf(stderr,"ERROR: Unpacked parameters are not acceptable. \n");
      return NULL;
    }
    param = i;
    length = valid[i].L;
    k = valid[i].K;
    seed = packed[2];
  }

  q = (struct lfgen *) mymalloc(sizeof(struct lfgen));
  if(q == NULL)
    return NULL;

#if OLD
  q->si = (unsigned *) mymalloc((length-1)*sizeof(unsigned));
  q->r0 = (unsigned *) mymalloc(length*sizeof(unsigned));
  q->r1 = (unsigned *) mymalloc(length*sizeof(unsigned));
#else
  desired_malloc = (length*3-1)*sizeof(unsigned);
  q->si = (unsigned *) mymalloc(desired_malloc);
  q->r0 = (unsigned *) (q->si + length - 1);
  q->r1 = (unsigned *) (q->r0 + length);
#endif
  q->lval = length;
  q->kval = k;
  q->seed = seed;
  q->param = param;
  q->init_seed = packed[3];

  if (q->r1 == NULL || q->si == NULL || q->r0 == NULL)
    return NULL;


  for (i=0;i<length-1;i++)
    q->si[i] = packed[i+4];
  for (i=0;i<length;i++)
    q->r0[i] = packed[length+i+3];
  for (i=0;i<length;i++)
    q->r1[i] = packed[2*length+i+3];

  q->hptr = packed[3*length+3];

  NGENS++;

  return (int *) q;
}

/*************************************************************************/
/*************************************************************************/
/*      FREE_RNG: remove memory for a generator                          */
/*************************************************************************/
/*************************************************************************/

#if __STDC__
int free_rng(int *genptr)
#else
int free_rng(genptr)
int *genptr;
#endif
{
  struct lfgen *q;

  q = (struct lfgen *)genptr;
  free(q->si);

#if OLD
  free(q->r0);
  free(q->r1);
#endif
  free(q);

  NGENS--;

  if(!NGENS && order_size)
  {
      free(order);
      order = 0;
      order_size = 0;
  }

  return NGENS;
}



#if __STDC__
int print_rng( int *igen)
#else
int print_rng(igen)
int *igen;
#endif
{
  struct lfgen *gen;

  printf("\nLagged Fibonacci Generator:\n");

    gen = (struct lfgen *) igen;
  printf("\n \tseed = %u, lags = (%d,%d)\n\n",
           gen->init_seed,gen->lval, gen->kval);

  return 1;
}

#include "simple_.h"

/* Manually turning off FORTRAN wrappers - TME */
/* #include "fwrap_.h" */
